# 동시성 이슈 보고서

## 문제 인식
- 이커머스 서비스를 운영할 때 동시성 이슈가 발생할 만한 공유자원은 대표적으로 재고수량이 있을 것이다.
- 주문자들이 주문에 성공할 때 각자 재고 차감을 요청하게 되는데, 이 때 재고는 무한정이 아닌 0 미만으로 내려가면 안되는 한정된 공유자원이기 때문에 경합이 발생한다.
- 현재 이커머스 서비스의 구조는 주문 자체에 재고 차감로직이 있는 것이 아닌 결제시 차감하도록 되어있어 purchase.facade의 purchaseOrder메소드의 통합테스트 코드에 동시성 테스트 시나리오를 추가하였다.

## 상황 분석
- 테스트 시나리오는 세명의 유저가 재고 6인 상황에서 각각 2개씩 주문을 생성한 상황에서 결제 직전에 재고가 1개 소진되어 5개가 남아있고, 세명이 동시에 주문해서 경합이 발생하게 만들었다.
- 테스트 작성 시점에 동시성 이슈에 대한 대비가 되어있지 않아 테스트 실행 시 3건 모두 성공할 것으로 예상했으나 실제로는 3건 중 1건만 성공, 나머지 2건은 에러가 발생하였다.
- 2건이 실패한 원인 분석 결과 재고 차감 후 일일 판매량 테이블을 증가시켜야 하는데, 상품 id와 날짜를 묶어 유니크 조건이 걸려있어서 테스트 환경에서 3건이 동시에 create를 진행하면서 동시성에 의한 조건 위배 에러가 발생한 것이었다.

## 문제 해결
- 위와 같이발생한 동시성 문제를 해결하기 위해 동시성 감지 조건을 걸고, 실패했을 경우에 정해진 횟수만큼 재시도하는 방식의 낙관적 락을 구현하였다.
- 낙관적 락을 사용한 이유는
  1. 기존에도 결제 요청 시 먼저 재고와 주문량을 비교해 재고가 부족하면 즉시 예외처리를 하기 때문에 서버가 나머지 조건들을 검사후 트랜잭션을 처리하는 짧은 시간 내에 다른 결제 건이 들어와서 주문량을 비교하고, 트랜잭션에 돌입하는 상황은 흔하지 않을 것이라고 판단
  2. 쇼핑몰 사이트는 콘서트 예매와는 다르게 상품과 재고가 희소하여 구매자들 사이에서 경쟁하는 일은 잘 발생하지 않을 것이며, 만약 그런 상황이 빈번하다면 '물건이 많지 않은 쇼핑몰'과 같은 인식으로 고객 만족도가 떨어질 수 있어 시스템적 뿐만 아니라 비즈니스적으로 지양하는 것이 좋다고 판단되었다.
- 구체적인 구현은 purchaseOrder의 시작 부분부터 트랜잭션 유닛으로 묶어 동시성 감지 시 처음부터 재시도하도록 하였다.
- 일일 판매량 증가에 대한 동시성은 테스트에서 발견한 것과 같이 유니크 조건을 위배하고 새로 row를 생상하려는 시도에 대한 에러로 감지하였다.
- 최초에 우려점이었던 재고차감에 있어서 동시성 이슈 발생은 재고를 담당하는 productOption에 version칼럼을 두어 재고를 차감하려는 version과 다르면 동시성을 감지할 수 있도록 하였다.
- 포인트 부족이나 재고 부족과 같은 에러는 동시성 상황을 회피해 재시도한다고 해도 해결될 수 없는 문제이므로 즉시 종료한다.
- 선착순 쿠폰 발급 또한 재고차감과 마찬가지로 경합조건이므로 유사하게 동시성 처리를 구현했다.

## 대안 모색
- 구현의 용이성을 위해 메소드의 시작부터 끝까지 트랜잭션에 포함시켰는데, 재고 차감 등 update관련 액션이 있기 전에 read하는 동작이나 동시성 우려가 해소된 뒤 update하는 동작은 트랜잭션 바깥으로 빼서 트랜잭션 유닛을 줄이는 방안이 있을 것으로 보인다.
- 위 아이디어에 대한 구체적인 사례로 purchaseOrder에서 동시성 문제가 생기는 근본 원인은 재고 차감이므로 productOption에 대한 업데이트가 완료된 이후에는 경합조건이 해소되었다고 보고 트랜잭션에서 뺴도 될 것 같다. 더불어 productOption의 업데이트와 연관이 있는 것들을 순서상 모아서 트랜잭션 유닛을 줄이는 전략을 취할 수도 있을 것으로 예상된다.
- row에 대한 락을 기본전제로 삼아서 한 공유자원에 여러 유저가 몰리는 경우를 중점적으로 고려했는데, 포인트 충전/차감과 같이 한유저만 접근하는 row에 대해서도 유저 한명이 동시에 여러번 요청하는 일이 빈번하진 않더라도 가능성을 배제할 수 없으니 낙관적 락을 거는 것이 바람직하다. 이 때는 0원 차감을 오감지하는 등 엄밀하지는 않겠지만 비즈니스 정책에 따라 유저의 balance 값을 version대신 사용해서 동시성을 감지할 수 있을 것이라 생각된다.